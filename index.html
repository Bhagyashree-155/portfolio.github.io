<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Hello, I'm Bhagyashree Anand Mugalkhod üëã</h1>
        <p>I am passionate about technology and problem-solving. Here's a glimpse of my work:</p>
    </header>

    <section>
        <h2>üõ† Projects</h2>
        <ul>
            <li><strong>Engineering Exploration</strong>:Toroidal Winding Machine</li>
            <li><strong>Design Thinking And Social Innovation</strong>:Problems Caused Due TO Downed Electric Wires</li>
        </ul>

        <h2>üöÄ Skills</h2>
        <ul>
            <li>C++, Python, JavaScript</li>
            <li>Data Structures and Algorithms</li>
            <li>Web Development (React.js, Node.js)</li>
        </ul>

        <h2>üåê Find Me Online</h2>
        <ul>
            <li><a href="https://github.com/Swathi10bvb2004" target="_blank">GitHub</a></li>
        </ul>

        <h2>Portfolio Topic</h2>
        <dl>
            <dt>Course Name</dt>
            <dd>Design Analysis And Algorithrm</dd>

            <dt>Course Code</dt>
            <dd>24ECAC203</dd>

            <dt>Name</dt>
            <dd>Bhagyashree.Anand.Mugalkhod</dd>

            <dt>SRN</dt>
            <dd>01FE23BCI118</dd>

            <dt>Course Instructor</dt>
            <dd>K M M Rajashekharaiah</dd>

            <dt>University</dt>
            <dd>KLE Techological University</dd>

            <dt>Portfolio Topic/Domain</dt>
            <dd>City Design</dd>
        </dl>

        <blockquote>‚ÄúThe only way to do great work is to love what you do.‚Äù ‚Äì Steve Jobs</blockquote>
    </section>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio for DAA Lab</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        .code {
            background: #e8e8e8;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
       >

        <hr>

        <section>
            <h2>Key Concepts / Things Learned in This Course</h2>

            <h3>Time Complexity Analysis</h3>
            <h4>Task 1</h4>
            <p>Write a recursive C++ program for the Towers of Brahma problem and record the time taken for given input sizes. Use a spreadsheet application and plot a graph presenting your results.</p>
            <pre class="code"><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;

void towers(int n, string from, string to, string aux) {
    if (n == 1) {
        cout &lt;&lt; "Move disc 1 from " &lt;&lt; from &lt;&lt; " to " &lt;&lt; to &lt;&lt; endl;
        return;
    }
    towers(n-1, from, aux, to);
    cout &lt;&lt; "Move disc " &lt;&lt; n &lt;&lt; " from " &lt;&lt; from &lt;&lt; " to " &lt;&lt; to &lt;&lt; endl;
    towers(n-1, aux, to, from);
}

int main() {
    int n;
    string A = "A", B = "B", C = "C";
    cin &gt;&gt; n;

    clock_t start = clock();
    towers(n, A, C, B);
    clock_t end = clock();
    double elapsed = double(end - start) / CLOCKS_PER_SEC;
    cout &lt;&lt; "Time taken for execution: " &lt;&lt; elapsed &lt;&lt; " seconds" &lt;&lt; endl;
    return 0;
}
</code></pre>

            <table>
                <thead>
                    <tr>
                        <th>X-axis (Input)</th>
                        <th>Y-axis (Time)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1</td><td>0.649</td></tr>
                    <tr><td>2</td><td>0.65</td></tr>
                    <tr><td>3</td><td>0.937</td></tr>
                    <tr><td>4</td><td>1.554</td></tr>
                    <tr><td>5</td><td>1.98</td></tr>
                    <tr><td>6</td><td>3.365</td></tr>
                </tbody>
            </table>

            <h4>Task 2</h4>
            <p>Compare and present the orders of growth of linear search and binary search for best-case, worst-case, and average-case inputs. Use the rand() function to generate random array inputs between size 0 to 1000. Present results using graphs.</p>
            <pre class="code"><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
using namespace std;

#define SIZE 50000
#define ITER 10000

int linear_search(int a[SIZE], int target) {
    for (int i = 0; i < SIZE; i++) {
        if (a[i] == target) return i;
    }
    return -1;
}

int binary_search(int a[SIZE], int target) {
    int low = 0, high = SIZE - 1, mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (a[mid] == target) return mid;
        if (target > a[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

int main() {
    int a[SIZE], target;
    srand(78);

    for (int i = 0; i < SIZE; i++) {
        a[i] = rand() % SIZE;
    }

    cout &lt;&lt; "Enter the target number to search: ";
    cin &gt;&gt; target;

    clock_t start = clock();
    for (int i = 0; i < ITER; i++) {
        linear_search(a, target);
    }
    clock_t end = clock();
    double linearTime = double(end - start) / (CLOCKS_PER_SEC * ITER);
    cout &lt;&lt; "Linear Search Time (average per iteration): " &lt;&lt; linearTime &lt;&lt; " seconds" &lt;&lt; endl;

    sort(a, a + SIZE);

    start = clock();
    for (int i = 0; i < ITER; i++) {
        binary_search(a, target);
    }
    end = clock();
    double binaryTime = double(end - start) / (CLOCKS_PER_SEC * ITER);
    cout &lt;&lt; "Binary Search Time (average per iteration): " &lt;&lt; binaryTime &lt;&lt; " seconds" &lt;&lt; endl;

    return 0;
}
</code></pre>
        </section>
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Concepts and Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 15px;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DAA Concepts and Examples</h1>

        <h2>Length of String</h2>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

// Function to calculate the length of the string recursively
int getlength(char *str, int length) {
    if(*str != '\0'){
        length++;
        str++;
        return getlength(str, length);
    }
    return length;
}

int main() {
    char str[100];
    int length = 0;
    printf("Enter a string: ");
    scanf("%s", str);

    // Start measuring time
    clock_t start = clock();

    // Calculate the length of the string
    length = getlength(str, length);

    // Stop measuring time
    clock_t end = clock();
    double elapsed = ((double)(end - start)) / CLOCKS_PER_SEC;

    // Print the result
    printf("The length is %d\n", length);
    printf("Time taken for execution: %f seconds\n", elapsed);

    return 0;
}
        </pre>

        <table>
            <thead>
                <tr>
                    <th>Length (n)</th>
                    <th>Library</th>
                    <th>Recursion</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>100</td><td>3</td><td>3</td></tr>
                <tr><td>500</td><td>3</td><td>3</td></tr>
                <tr><td>1000</td><td>4</td><td>4</td></tr>
                <tr><td>5000</td><td>4</td><td>4</td></tr>
                <tr><td>10000</td><td>5</td><td>5</td></tr>
                <tr><td>50000</td><td>5</td><td>5</td></tr>
            </tbody>
        </table>

        <h3>Challenges in Learning</h3>
        <ul>
            <li>Understanding time complexity of algorithms like Tower of Hanoi, linear and binary search, and string length calculations.</li>
            <li>Strong mathematical foundations and abstract nature of theoretical concepts.</li>
        </ul>

        <h3>Challenges in Correlating with Real-World Applications</h3>
        <ul>
            <li>Adapting algorithms to handle real-world data and constraints.</li>
            <li>Bridging the gap between abstract ideas and practical use.</li>
        </ul>

        <h3>Determining Efficient Approaches</h3>
        <ul>
            <li>Clearly define the problem and break it down into smaller parts.</li>
            <li>Research existing solutions and iteratively test and refine the approach.</li>
        </ul>

        <h2>Binary Search Tree</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

struct tree {
    int data;
    struct tree* left;
    struct tree* right;
};

typedef struct tree TREE;

class Binarysearchtree {
public:
    TREE* insert_into_bst(TREE*, int);
    void inorder(TREE*);
    void preorder(TREE*);
    void postorder(TREE*);
    TREE* delete_from_bst(TREE*, int);
};

TREE* Binarysearchtree::insert_into_bst(TREE* root, int data) {
    TREE* newnode = (TREE*)malloc(sizeof(TREE));
    if (newnode == NULL) {
        cout &lt;&lt; "Memory allocation failed" &lt;&lt; endl;
        return root;
    }
    newnode->data = data;
    newnode->left = NULL;
    newnode->right = NULL;
    if (root == NULL) {
        root = newnode;
        cout &lt;&lt; "Root node inserted into tree" &lt;&lt; endl;
        return root;
    }
    TREE* curnode = root;
    TREE* parent = NULL;
    while (curnode != NULL) {
        parent = curnode;
        if (newnode->data < curnode->data) {
            curnode = curnode->left;
        } else {
            curnode = curnode->right;
        }
    }
    if (newnode->data < parent->data) {
        parent->left = newnode;
    } else {
        parent->right = newnode;
    }
    cout &lt;&lt; "Node inserted successfully into the tree" &lt;&lt; endl;
    return root;
}

// Inorder Traversal
void Binarysearchtree::inorder(TREE* root) {
    if (root != NULL) {
        inorder(root->left);
        cout &lt;&lt; root->data &lt;&lt; "\t";
        inorder(root->right);
    }
}

// Preorder Traversal
void Binarysearchtree::preorder(TREE* root) {
    if (root != NULL) {
        cout &lt;&lt; root->data &lt;&lt; "\t";
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder Traversal
void Binarysearchtree::postorder(TREE* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        cout &lt;&lt; root->data &lt;&lt; "\t";
    }
}

// Delete Node
TREE* Binarysearchtree::delete_from_bst(TREE* root, int data) {
    TREE* curnode = root;
    TREE* parent = NULL;
    TREE* successor = NULL;
    TREE* p = NULL;

    if (root == NULL) {
        cout &lt;&lt; "TREE is empty" &lt;&lt; endl;
        return root;
    }

    while (curnode != NULL && curnode->data != data) {
        parent = curnode;
        if (data < curnode->data) {
            curnode = curnode->left;
        } else {
            curnode = curnode->right;
        }
    }

    if (curnode == NULL) {
        cout &lt;&lt; "Item not found" &lt;&lt; endl;
        return root;
    }

    if (curnode->left == NULL) {
        p = curnode->right;
    } else if (curnode->right == NULL) {
        p = curnode->left;
    } else {
        successor = curnode->right;
        while (successor->left != NULL) {
            successor = successor->left;
        }
        successor->left = curnode->left;
        p = curnode->right;
    }
    if (parent == NULL) {
        free(curnode);
        return p;
    }

    if (curnode == parent->left) {
        parent->left = p;
    } else {
        parent->right = p;
    }
    free(curnode);
    return root;
}

int main() {
    Binarysearchtree bst;
    TREE* root = NULL;
    int choice = 0, data = 0;
    while (1) {
        cout &lt;&lt; "\n*MENU\n";
        cout &lt;&lt; "1-Insert into BST\n";
        cout &lt;&lt; "2-Inorder Traversal\n";
        cout &lt;&lt; "3-Preorder Traversal\n";
        cout &lt;&lt; "4-Postorder Traversal\n";
        cout &lt;&lt; "5-Delete from BST\n";
        cout &lt;&lt; "Any other option to exit\n";
        cout &lt;&lt; "*\n";

        cout &lt;&lt; "Enter your choice: ";
        cin &gt;&gt; choice;
        switch (choice) {
            case 1:
                cout &lt;&lt; "Enter the item to insert: ";
                cin &gt;&gt; data;
                root = bst.insert_into_bst(root, data);
                break;
            case 2:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Inorder traversal is..\n";
                    bst.inorder(root);
                }
                break;
            case 3:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Preorder traversal is..\n";
                    bst.preorder(root);
                }
                break;
            case 4:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Postorder traversal is..\n";
                    bst.postorder(root);
                }
                break;
            case 5:
                cout &lt;&lt; "Enter the item to be deleted: ";
                cin &gt;&gt; data;
                root = bst.delete_from_bst(root, data);
                break;
            default:
                cout &lt;&lt; "Exiting code:\n";
                exit(0);
        }
    }
    return 0;
}
        </pre>

        <h3>Challenges in Learning</h3>
        <ul>
            <li>Understanding hierarchical structure and recursive operations in binary search trees.</li>
            <li>Handling edge cases like duplicate keys or node deletions.</li>
        </ul>

        <h3>Challenges in Correlating with Real-World Applications</h3>
        <ul>
            <li>Identifying use cases and performance trade-offs in dynamic scenarios.</li>
            <li>Maintaining balanced structures for efficiency.</li>
        </ul>

        <h3>Determining Efficient Approaches</h3>
        <ul>
            <li>Analyze problem requirements and compare with alternatives like hash tables or balanced trees.</li>
            <li>Test with real-world data and evaluate complexity.</li>
        </ul>
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Concepts and Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 15px;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DAA Concepts and Examples</h1>

        <h2>Depth-First Search (DFS) and Breadth-First Search (BFS)</h2>
        <h3>DFS Code</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

int v = 5;
int m[10][10] = {{0,1,1,0,0}, {1,0,0,1,1},
        {1,0,0,0,1}, {0,1,0,0,0}, {0,1,1,0,0}};
int visited[10];

void dfs(int m[10][10], int v, int source) {
    visited[source] = 1;
    for (int i = 0; i < v; i++) {
        if (m[source][i] == 1 && visited[i] == 0) {
            cout &lt;&lt; i &lt;&lt; "\t";
            dfs(m, v, i);
        }
    }
}
int main() {
    int source;
    for (int i = 0; i < v; i++)
        visited[i] = 0;

    cout &lt;&lt; "Enter the source vertex: ";
    cin &gt;&gt; source;

    cout &lt;&lt; "The DFS Traversal is... \n";
    cout &lt;&lt; source &lt;&lt; "\t";
    dfs(m, v, source);

    return 0;
}
        </pre>

        <h3>BFS Code</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

void bfs(int m[10][10], int v, int source) {
    int queue[20];
    int front = 0, rear = 0, u, i;
    int visited[10];

    for (i = 0; i < v; i++)
        visited[i] = 0;

    queue[rear] = source;
    visited[source] = 1;

    cout &lt;&lt; "The BFS Traversal is... \n";

    while (front <= rear) {
        u = queue[front];
        cout &lt;&lt; u &lt;&lt; "\t";
        front++;

        for (i = 0; i < v; i++) {
            if (m[u][i] == 1 && visited[i] == 0) {
                visited[i] = 1;
                rear++;
                queue[rear] = i;
            }
        }
    }
}

int main() {
    int v = 5;
    int m[10][10] = {{0,1,1,0,0}, {1,0,0,1,1},
        {1,0,0,0,1}, {0,1,0,0,0}, {0,1,1,0,0}};

    int source;
    cout &lt;&lt; "Enter the source vertex: ";
    cin &gt;&gt; source;

    bfs(m, v, source);

    return 0;
}
        </pre>

        <h3>Challenges in Learning DFS and BFS</h3>
        <ul>
            <li>Difficulty understanding traversal mechanisms and implementation details.</li>
            <li>Managing data structures like stacks (DFS) or queues (BFS).</li>
            <li>Handling edge cases like cycles and disconnected graphs.</li>
        </ul>

        <h3>Challenges in Correlating DFS and BFS with Real-World Applications</h3>
        <ul>
            <li>Mapping abstract nodes and edges to real-world entities like cities or networks.</li>
            <li>Choosing the appropriate graph representation for a given scenario.</li>
        </ul>

        <h2>Heap</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void Heapify(vector&lt;int&gt;& H, int i, int n) {
    int v;
    for (int i = n / 2; i >= 1; i--) {
        v = H[i];
        bool heap = false;

        while (!heap && 2 * i <= n) {
            int j = 2 * i;

            if (j < n && H[j] < H[j + 1]) {
                j = j + 1;
            }
            if (v >= H[j]) {
                heap = true;
            } else {
                H[i] = H[j];
                i = j;
            }
        }
        H[i] = v;
    }
}

int main() {
    vector&lt;int&gt; H = {7, 6, 17, 11, 64, 29, 6, 12, 2};
    for (int i = 1; i < H.size(); i++) {
        cout &lt;&lt; H[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
    int n = H.size();
    int i;
    Heapify(H, i, n);
    cout &lt;&lt; "After heapification\n";
    for (int i = 1; i < H.size(); i++) {
        cout &lt;&lt; H[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
        </pre>

        <h3>Challenges in Learning Heaps</h3>
        <ul>
            <li>Visualizing binary tree structure when implemented using arrays.</li>
            <li>Understanding and maintaining the "heap property" during insertion and deletion.</li>
        </ul>

        <h3>Challenges in Correlating Heaps with Real-World Applications</h3>
        <ul>
            <li>Identifying scenarios where heaps are optimal, such as priority queues or shortest path algorithms.</li>
            <li>Adapting heap implementations for large-scale systems or specific use cases.</li>
        </ul>

    </div>
</body>
</html>
